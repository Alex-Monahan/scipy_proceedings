\documentclass[letterpaper,compsoc,twoside]{IEEEtran}
% generated by Docutils <http://docutils.sourceforge.net/>
\usepackage{cmap} % fix search and cut-and-paste in Acrobat
\usepackage{ifthen}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{color}

\usepackage[font={small,it},labelfont=bf]{caption}
\usepackage{float}
%%%ADDITION WM%%%%%
\usepackage {graphicx} 
\usepackage[rightcaption]{sidecap}
\usepackage{subfigure} 
\definecolor{rebeccapurple}{RGB}{102, 51, 153}
\definecolor{gold}{RGB}{255,191,0}
\definecolor{yellowgreen}{RGB}{154,205,50}
\definecolor{darkviolet}{RGB}{148, 0, 211}
\usepackage{bbding}
\usepackage{floatrow}
%%%%%%%%%%%%%%%%%%%%%%

\setcounter{secnumdepth}{0}

%%% Custom LaTeX preamble
\usepackage{scipy}
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PY@tok@cs\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PY@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PY@tok@ne\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PY@tok@nl\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PY@tok@nd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PY@tok@si\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PY@tok@fm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PY@tok@vm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PY@tok@sa\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PY@tok@dl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PY@tok@mb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PY@tok@ch\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PY@tok@cpf\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


%%% User specified packages and stylesheets

%%% Fallback definitions for Docutils-specific commands
% basic code highlight:
\providecommand*\DUrolecomment[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\providecommand*\DUroledeleted[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\providecommand*\DUrolekeyword[1]{\textbf{#1}}
\providecommand*\DUrolestring[1]{\textit{#1}}

% inline markup (custom roles)
% \DUrole{#1}{#2} tries \DUrole#1{#2}
\providecommand*{\DUrole}[2]{%
  \ifcsname DUrole#1\endcsname%
    \csname DUrole#1\endcsname{#2}%
  \else
    % backwards compatibility: try \docutilsrole#1{#2}
    \ifcsname docutilsrole#1\endcsname%
      \PackageWarningNoLine{docutils}{Command prefix "docutilsrole" is
         deprecated, \MessageBreak use `\protect\DUrole #1`}
      \csname docutilsrole#1\endcsname{#2}%
    \else%
      #2%
    \fi%
  \fi%
}

% hyperlinks:
\ifthenelse{\isundefined{\hypersetup}}{
  \usepackage[colorlinks=true,linkcolor=blue,urlcolor=blue]{hyperref}
  \usepackage{bookmark}
  \urlstyle{same} % normal text font (alternatives: tt, rm, sf)
}{}

%%% Body
\begin{document}
\newcounter{footnotecounter}\title{pyDAMPF: a Python package for modeling mechanical properties of hygroscopic materials under interaction with a nanoprobe}\author{Willy Menacho N.$^{\setcounter{footnotecounter}{3}\fnsymbol{footnotecounter}}$\setcounter{footnotecounter}{3}\thanks{\fnsymbol{footnotecounter} Instituto de Investigaciones Físicas. Carrera de Física, Universidad Mayor de San Andrés. Campus Universitario Cota Cota. La Paz, Bolivia}\setcounter{footnotecounter}{4}\thanks{\fnsymbol{footnotecounter} Department of Theoretical Physics, Jo\v{z}ef Stefan Institute, Jamova 39, 1000 Ljubljana, Slovenia.}, Gonzalo Marcelo Ramírez- Ávila$^{\setcounter{footnotecounter}{3}\fnsymbol{footnotecounter}}$, Horacio V. Guzman$^{\setcounter{footnotecounter}{3}\fnsymbol{footnotecounter}\setcounter{footnotecounter}{4}\fnsymbol{footnotecounter}\setcounter{footnotecounter}{1}\fnsymbol{footnotecounter}}$%
          \setcounter{footnotecounter}{1}\thanks{\fnsymbol{footnotecounter} %
          Corresponding author: \protect\href{mailto:horacio.guzman@ijs.si}{horacio.guzman@ijs.si}}\thanks{%

          \noindent%
          Copyright\,\copyright\,2022 Willy Menacho N. et al. This is an open-access article distributed under the terms of the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.%
        }}\maketitle
          \renewcommand{\leftmark}{PROC. OF THE 21th PYTHON IN SCIENCE CONF. (SCIPY 2022)}
          \renewcommand{\rightmark}{pyDAMPF: a Python package for modeling mechanical properties of hygroscopic polymeric nanofibers}
        
\InputIfFileExists{page_numbers.tex}{}{}
\newcommand*{\docutilsroleref}{\ref}
\newcommand*{\docutilsrolelabel}{\label}
\newcommand*\DUrolecode[1]{#1}
\providecommand*\DUrolecite[1]{\cite{#1}}
\begin{abstract}
pyDAMPF is a tool oriented to the Atomic Force Microscopy (AFM) community, which allows the simulation of the physical properties of materials under variable relative humidity (RH). In particular, pyDAMPF is mainly focused on the mechanical properties of polymeric hygroscopic nanofibers that plays an essential role in designing of tissue scaffolds for implants and filtering devices. Those mechanical properties have been mostly studied from a very coarse perspective reaching a micrometer scale. However, at the nanoscale, the mechanical response of polymeric fibers becomes cumbersome due to both experimental and theoretical challenges. For example, the response of polymeric fibers to RH demands advanced models that consider sub-nanometric changes in the local structure of each single polymer chain. While from an experimental viewpoint, choosing the optimal cantilevers to scan the fibers under variable RH is not trivial.

In this article, we show how to use pyDAMPF to choose one optimal nanoprobe for planed experiments with an hygroscopic polymer. Along these lines, We show how to evaluate common and non-trivial operational parameters from an AFM cantilever from several manufacturers. Our results show in a stepwise approach the most relevant parameters to compare the cantilevers based on a non-invasive criterion of measurements. The computing engine is written in Fortran in order to reuse physics code and wrapped to Python to interoperate with high-level packages. We also introduce an in-house and transparent for the user multi-thread approach of the pyDAMPF code, which compares for various computing architectures (PC, Google Colab and an HPC facility) very favorable in comparison to former AFM simulators. 
\end{abstract}\begin{IEEEkeywords} Materials science, Nanomechanical properties, AFM, f2py, multi-threading CPUs, numerical simulations, polymers\end{IEEEkeywords}

\subsection{Introduction and Motivation%
  \label{Intro}%
}

This article provides an overview of pyDAMPF, which is a BSD licensed, Python and Fortran simulation tool that enables AFM users to simulate the interaction between a probe (cantilever) and materials at the nanoscale under diverse environments. The code is packaged in a bundle and hosted on GitHub at \url{https://github.com/govarguz/pyDAMPF}. 

Despite the recent open-source availability of dynamic AFM simulation packages~\cite{dForce,Veda}, a broad usage for the assessment and planning of experiments has yet to come. One of the problems is that it is often hard to simulate several operational parameters at once. For example, most scientists evaluate different AFM cantilevers before starting new experiments. A typical evaluation criterion is the maximum exerted force that prevents invasivity of the nanoprobe into the sample. The variety of AFM cantilevers depends on the geometrical and material characteristics used for its fabrication. Moreover, manufacturers' nanofabrication techniques may change from time to time, according to the necessities of the experiments, like sharper tips and/or higher oscillation frequencies. 
From a simulation perspective, evaluating observables for reaching optimal results on upcoming experiments is nowadays possible for \textit{tens} or \textit{hundreds} of cantilevers. On top of other operational parameters in the case of dynamic AFM like the oscillation amplitude $A_0$, set-point $A_{sp}$, among other materials expected properties that may feed simulations and create simulations batches of easily \textit{thousands} of cases. 
Given this context, we focus this article on choosing a cantilever out of an initial pyDAMPF database of 30. In fact, many of them are similar in terms of spring constant $k_c$, cantilever volume $V_c$ and also Tip's radius $R_T$. Then we focus on seven archetypical and distinct cases/cantilevers to understand the characteristics of each of the parameters specified in the manufacturers' datasheets, by evaluating the maximum (peak) forces.

We present four scenarios comparing a total of seven cantilevers and the same sample, where we use as a test-case Poly-Vinyl Acetate (PVA) fiber. The first scenario (Figure~\ref{fig1}(a)) illustrates the difference between air and a moist environment. On the second one, a cantilever, only a very soft and stiff cantilever spring constants are compared (see Figure~\ref{fig1}(b)).At the same time, the different volumes along the 30 cantilevers is depicted in Figure~\ref{fig1}(a). A final and mostly very common comparison is scenario 4, by comparing one of the most sensitive parameters to the force of the tip's radii (see Figure~\ref{fig1}(d)).

The quantitative analysis for these four scenarios is presented and also the advantages of computing several simulation cases at once with our in-house development. Such a comparison is performed under the most common computers used in science, namely, personal computers (PC), cloud (Colab) and supercomputing (small Xeon based cluster). We reach a Speed-up of $~$ 20 over the former implementation~\cite{dForce}.

Another novelty of pyDAMPF is the detailed~\cite{Sader} calculation of the environmental-related parameters, like the quality factor $Q$. 
%This computing efficiency and adaptability is not available in any other open source AFM simulation tool. 

Here, we summarize the main features of pyDAMPF are:
\begin{itemize}
\item 

Highly efficient structure in terms of time-to-result, at least one order of magnitude faster than existing approaches.
\item 
Easy to use for scientists without a computing background, in particular in the use of multi-threads.
\item
It supports the addition of further AFM cantilevers and parameters into the code database.
\item 

Allows an interactive analysis, including a graphical and table-based comparison of results through Jupyter Notebooks.
\end{itemize}


%Compyle is in principle very similar to the \href{https://github.com/bryancatanzaro/copperhead}{copperhead} package described in \DUrole{cite}{copperhead2011}. 

 %\DUrole{cite}{schroeder2015}. Our goal
The results presented in this article are available as \href{https://colab.research.google.com/drive/1ZM_aQsuYWUD2gnhcIhngpypJ6m1MbFxE?usp=sharing}{Google
Colaboratory notebook}, which facilitates to explore pyDAMPF and these examples.

\subsection{Methods%
  \label{Methods}%
}

\subsubsection{Processing inputs%
  \label{inputs}%
}
pyDAMPF counts with an initial database of 30 cantilevers, which can be extended at any time by accessing to the file \textit{cantilevers\_data.txt} then, the program inputs\_processor.py  reads the cantilever database and asks for further physical and operational variables, required to start the simulations. This will generate \textit{tempall.txt}, which contains all cases \textit{e.g.} 30 to be simulated with pyDAMPF

\begin{Verbatim}[commandchars=\\\{\},fontsize=\footnotesize]
\PY{k}{def} \PY{n+nf}{inputs\PYZus{}processor}\PY{p}{(}\PY{n}{variables}\PY{p}{,}\PY{n}{data}\PY{p}{)}\PY{p}{:}
    \PY{n}{a\PY{p}{,}b} \PY{o}{=} \PY{n}{np.shape}\PY{p}{(}\PY{n}{data}\PY{p}{)}
    \PY{n}{final} \PY{o}{=} \PY{n}{gran\PYZus{}permutador}\PY{p}{(} \PY{n}{variables}\PY{p}{,} \PY{n}{data}\PY{p}{)}
    \PY{n}{f\PYZus{}name} \PY{o}{=} \PY{p}{'} \PY{n}{tempall.txt}\PY{p}{'} 
    \PY{n}{np.savetxt}\PY{p}{(}\PY{n}{f\PYZus{}name}\PY{p}{,}\PY{n}{final}\PY{p}{)}
    \PY{n}{directory} \PY{o}{=} \PY{n}{os.getcwd}\PY{p}{(}\PY{p}{)}
    \PY{n}{shutil.copy}\PY{p}{(}\PY{n}{directory}\PY{p}{+}\PY{p}{'}\PY{p}{/}\PY{n}{tempall.txt}\PY{p}{'}\PY{p}{,}\PY{n}{directory}\PY{p}{+}\PY{p}{'}
               \PY{p}{/}\PY{n}{EXECUTE}\PYZus{}pyDAMPF\PY{p}{/}\PY{p}{'}\PY{p}{)}
    \PY{n}{shutil.copy}\PY{p}{(}\PY{n}{directory}\PY{p}{+}\PY{p}{'}\PY{p}{/}\PY{n}{tempall.txt}\PY{p}{'}\PY{p}{,}\PY{n}{directory}\PY{p}{+}\PY{p}{'}
               \PY{p}{/}\PY{n}{EXECUTE}\PYZus{}pyDAMPF\PY{p}{/}\PY{n}{pyDAMPF}\PYZus{}BASE\PY{p}{/}\PY{n}{nrun}\PY{p}{/}\PY{p}{'}\PY{p}{)}    
\end{Verbatim}
\vspace{1mm}        

The variables inside the argument of the function \textit{inputs\_processor} are interactively requested from a shell command line. Then the file \textit{tempall.txt} is generated and copied to the folders that will contain the simulations.

\subsubsection{Execute pyDAMPF%
  \label{pyDAMPF}%
}
For execution on a single or multi-thread way, we require first to wrap our numeric core from Fortran to Python by using f2py~\cite{f2py}. Namely, the file \textit{pyDAMPF.f90} within the folder \textit{EXECUTE\_pyDAMPF}.

\paragraph{Compilation with f2py}
This step is only required once and depends on the computer architecture the code for this reads:

\begin{quote}
\begin{verbatim}
f2py -c --fcompiler=gnu95 pyDAMPF.f90 -m mypyDAMPF
\end{verbatim}
\end{quote}

This command-line generates mypyDAMPF.so, which will be automatically located in the simulation folders.

Once we have obtained the numerical code as Python modules, we need to choose the execution mode, which can be serial or parallel. Whereby parallel refers to multi-threading capabilities only within this first version of the code.

\paragraph{Serial method}

This method is completely transparent to the user and will execute all the simulation cases found in the file \textit{tempall.txt} by running the script \textitP{inputs\_processor.py}. Our in-house development creates an individual folder for each simulation case, which can be executed in one thread.

\begin{Verbatim}[commandchars=\\\{\},fontsize=\footnotesize]
\PY{k}{def} \PY{n+nf}{serial\PYZus{}method}\PY{p}{(}\PY{n}{tcases}\PY{p}{,} \PY{n}{factor}\PY{p}{,} \PY{n}{tempall}\PY{p}{)}\PY{p}{:}
    \PY{n}{lst} \PY{o}{=} \PY{n}{gen\PYZus{}limites}\PY{p}{(}\PY{n}{tcases}\PY{p}{,} \PY{n}{factor}\PY{p}{)}
    \PY{n}{change\PYZus{}dir}\PY{p}{(}\PY{p}{)}
    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{1}\PY{p}{,}\PY{n}{factor}\PY{p}{+}\PY{n}{1}\PY{p}{)}\PY{p}{:}
        \PY{n}{direc} \PY{o}{=} \PY{n}{os.getcwd}\PY{p}{(}\PY{p}{)}
        \PY{n}{direc2} \PY{o}{=} \PY{n}{direc}\PY{p}{+}\PY{p}{'}\PY{p}{/}\PY{n}{pyDAMPF\PYZus{}BASE}\PY{p}{/}\PY{p}{'}
        \PY{n}{direc3} \PY{o}{=} \PY{n}{direc}\PY{p}{+}\PY{p}{'}\PY{p}{/}\PY{n}{SERIALBASIC\PYZus{}0}\PY{p}{/}\PY{p}{'}\PY{p}{+}\PY{n}{str}\PY{p}{(}\PY{n}{i}\PY{p}{)}\PY{p}{+}\PY{p}{'}\PY{p}{/}\PY{p}{'}
        \PY{n}{shutil.copytree} \PY{p}{(} \PY{n}{direc2}\PY{p}{,}\PY{n}{direc3}\PY{p}{)}
    \PY{n}{os.chdir} \PY{p}{(} \PY{n}{direc}\PY{p}{+}\PY{p}{'}\PY{p}{/}\PY{n}{SERIALBASIC\PYZus{}0}\PY{p}{/}\PY{n}{1}\PY{p}{/}\PY{n}{nrun}\PY{p}{/}\PY{p}{'}\PY{p}{)}
    \PY{n+nb}{exec}\PY{p}{(}\PY{n+nb}{open}\PY{p}{(}\PY{p}{'}\PY{n}{generate\PYZus{}cases.py}\PY{p}{'}\PY{p}{)}\PY{p}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}\PY{p}{)}
    
\end{Verbatim}
\vspace{1mm}

As arguments, the serial method requires the total number of simulation cases obtained from \textit{tempall.txt}. In contrast, the \textit{factor} parameter has, in this case,a default value of 1.

\paragraph{Parallel method}

The parallel method uses more than one computational thread. It is similar to the serial method; however, this method distributes the total load along the available threads and executes in a parallel-fashion. This method comprises two parts: first, a function that takes care of the bookkeeping of cases and folders:

\begin{Verbatim}[commandchars=\\\{\},fontsize=\footnotesize]

\PY{k}{def} \PY{n+nf}{Parallel\PYZus{}method}\PY{p}{(}\PY{n}{tcases}\PY{p}{,} \PY{n}{factor}\PY{p}{,} \PY{n}{tempall}\PY{p}{)}\PY{p}{:}
    \PY{n}{lst} \PY{o}{=} \PY{n}{gen\PYZus{}limites}\PY{p}{(}\PY{n}{tcases}\PY{p}{,} \PY{n}{factor}\PY{p}{)}
    \PY{n}{change\PYZus{}dir}\PY{p}{(}\PY{p}{)}
    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{1}\PY{p}{,}\PY{n}{factor}\PY{p}{+}\PY{n}{1}\PY{p}{)}\PY{p}{:}
        \PY{n}{lim\PYZus{}inferior}\PY{o}{=}\PY{n}{lst}\PY{p}{[}\PY{n}{i-1}\PY{p}{]}\PY{p}{[}\PY{n}{0}\PY{p}{]}
        \PY{n}{lim\PYZus{}superior}\PY{o}{=}\PY{n}{lst}\PY{p}{[}\PY{n}{i-1}\PY{p}{]}\PY{p}{[}\PY{n}{1}\PY{p}{]}
        \PY{n}{direc} \PY{o}{=}\PY{n}{os.getcwd}\PY{p}{(}\PY{p}{)}
        \PY{n}{direc2} \PY{o}{=}\PY{n}{direc}\PY{p}{+}\PY{p}{'}\PY{p}{/}\PY{n}{pyDAMPF\PYZus{}BASE}\PY{p}{/}\PY{p}{'}
        \PY{n}{direc3} \PY{o}{=}\PY{n}{direc}\PY{p}{+}\PY{p}{'}\PY{p}{/}\PY{n}{SERIALBASIC\PYZus{}0}\PY{p}{/}\PY{p}{'}\PY{p}{+}\PY{n}{str}\PY{p}{(}\PY{n}{i}\PY{p}{)}\PY{p}{+}\PY{p}{'}\PY{p}{/}\PY{p}{'}
        \PY{n}{shutil.copytree} \PY{p}{(} \PY{n}{direc2}\PY{p}{,}\PY{n}{direc3}\PY{p}{)}
        \PY{n}{factorantiguo} \PY{o}{=} \PY{p}{'} \PY{n}{factor=1}\PY{p}{'}
        \PY{n}{factornuevo}\PY{o}{=}\PY{p}{'}\PY{n}{factor=}\PY{p}{'}\PY{p}{+}\PY{n}{str}\PY{p}{(}\PY{n}{factor}\PY{p}{)}
        \PY{n}{rangoantiguo} \PY{o}{=} \PY{p}{'}\PY{p}{(} \PY{n}{0,paraleliz}\PY{p}{)}{'}
        \PY{n}{rangonuevo}\PY{o}{=}\PY{p}{'}\PY{p}{(}\PY{p}{'}\PY{p}{+}\PY{n}{str}\PY{p}{(}\PY{n}{lim\PYZus{}inferior}\PY{p}{)}\PY{p}{+}\PY{p}{'}\PY{p}{,}\PY{p}{'}
                \PY{p}{+}\PY{n}{str}\PY{p}{(}\PY{n}{lim\PYZus{}superior}\PY{p}{)}\PY{p}{+}\PY{p}{'}\PY{p}{)}\PY{p}{'}
        \PY{n}{os.chdir}\PY{p}{(}\PY{n}{direc}\PY{p}{+}\PY{p}{'}\PY{p}{/}\PY{n}{PARALLELBASIC\PYZus{}0}\PY{p}{/}\PY{p}{'}\PY{p}{+}\PY{n}{str}\PY{p}{(}\PY{n}{i}\PY{p}{)}\PY{p}{)}
        \PY{n}{pyname} \PY{o}{=}\PY{p}{'} \PY{n}{nrun}\PY{p}{/}\PY{n}{generate_cases.py}\PY{p}{'}
        \PY{n}{newpath}\PY{o}{=}\PY{n}{direc}\PY{p}{+}\PY{p}{'}\PY{p}{/}\PY{n}{PARALLELBASIC\PYZus{}0}\PY{p}{/}\PY{p}{'}\PY{p}{+}\PY{n}{str}\PY{p}{(}\PY{n}{i}\PY{p}{)}\PY{p}{+}\PY{p}{'}\PY{p}{/}\PY{p}{'}
                \PY{p}{+}\PY{n}{pyname}
        \PY{n}{reemplazo}\PY{p}{(}\PY{n}{newpath}\PY{p}{,}\PY{n}{factorantiguo}\PY{p}{,}\PY{n}{factornuevo}\PY{p}{)}
        \PY{n}{reemplazo}\PY{p}{(}\PY{n}{newpath}\PY{p}{,}\PY{n}{rangoantiguo}\PY{p}{,}\PY{n}{rangonuevo}\PY{p}{)}
        \PY{n}{os.chdir}\PY{p}{(}\PY{n}{direc}\PY{p}{)}
\end{Verbatim}
\vspace{1mm}

This part generates serial-like folders for each thread's number of cases to be executed.

The second part of the parallel method will execute pyDAMPF, which contains at the same time two scripts. One for executing pyDAMPF in a common \textit{UNIX} based desktop or laptop. While the second is a python script that generated \textit{SLURM} code to launch jobs in HPC facilities.

\begin{itemize}
\item 
Execution with \textit{SLURM}

It runs pyDAMPF in different threads under the \textit{SLURM} queuing system.

\begin{Verbatim}[commandchars=\\\{\},fontsize=\footnotesize]

\PY{k}{def} \PY{n+nf}{cluster}\PY{p}{(}\PY{n}{factor}\PY{p}{)}\PY{p}{:}
    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in}\ \PY{n+nb}{range}\PY{p}{(}\PY{n}{1}\PY{p}{,}\PY{n}{factor+1}\PY{p}{)}\PY{p}{:}
        \PY{k}{with}\ \PY{n+nb}{open}\PY{p}{(}\PY{p}{'}\PY{n}{jobpyDAMPF}\PY{p}{'}\PY{p}{+}\PY{n}{str}\PY{p}{(}\PY{n}{i}\PY{p}{)}\PY{p}{+}\PY{p}{'}\PY{n}{.x}\PY{p}{'}\PY{p}{,}\PY{p}{'}\PY{n}{w}\PY{p}{'}\PY{p}{)}
                \PY{n+nb}{as}\ \PY{n}{ssf} \PY{p}{:}
            \PY{n}{ssf.write}\PY{p}{(}\PY{p}{'}\PY{p}{\#}\PY{p}{\!}\PY{p}{/}\PY{n}{bin}\PY{p}{/}\PY{n}{bash}\PY{p}{\-}\PY{n}{l}\PY{p}{|}\PY{n}{n }\PY{p}{'}\PY{p}{)}
            \PY{n}{ssf.write}\PY{p}{(}\PY{p}{'}\PY{p}{#}\PY{n}{SBATCH}\PY{p}{--}\PY{n}{time}\PY{p}{=}\PY{n}{23:00:00}
\PYZbs{}\PY{n}{n}\PY{p}{'}\PY{p}{)}
            \PY{n}{ssf.write}\PY{p}{(}\PY{p}{'}\PY{p}{#}\PY{n}{SBATCH}\PY{p}{--}\PY{n}{constraint}\PY{p}{=}
\PY{n}{epyc3}\PYZbs{}\PY{n}{n}\PY{p}{'}\PY{p}{)}
            \PY{n}{ssf.write}\PY{p}{(}\PY{p}{'}\PY{p}{#}\PYZbs{}\PY{n}{n}\PY{p}{'}\PY{p}{)}
            \PY{n}{ssf.write}\PY{p}{(}\PY{p}{'}\PYZbs{}\PY{n}{n}\PY{p}{'}\PY{p}{)}
            \PY{n}{ssf.write}\PY{p}{(}\PY{p}{'}\PY{n}{ml Anaconda3}\PY{p}{/}\PY{n}{2019.10}\PYZbs{}\PY{n}{n}\PY{p}{'}\PY{p}{)}
            \PY{n}{ssf.write}\PY{p}{(}\PY{p}{'}\PYZbs{}\PY{n}{n}\PY{p}{'}\PY{p}{)}    
            \PY{n}{ssf.write}\PY{p}{(}\PY{p}{'}\PY{n}{ml foss}\PY{p}{/}\PY{n}{2018a}\PYZbs{}\PY{n}{n}\PY{p}{'}\PY{p}{)}
            \PY{n}{ssf.write}\PY{p}{(}\PY{p}{'}\PYZbs{}\PY{n}{n}\PY{p}{'}\PY{p}{)}
            \PY{n}{ssf.write}\PY{p}{(}\PY{p}{'}\PY{n}{cd}\PY{p}{/}\PY{n}{home}\PY{p}{/}\PY{p}{$}\PY{p}{<}\PY{n}{USER}\PY{p}{>}\PY{p}{/}\PY{n}{pyDAMPF}\PY{p}{/}
\PY{n}{EXECUTE_pyDAMPF}\PY{p}{/}\PY{n}{PARALLELBASIC_0}\PY{p}{/}\PY{p}{'}\PY{p}{+}\PY{n}{str}\PY{p}{(}\PY{n}{i}\PY{p}{)}\PY{p}{+}\PY{p}{'}\PY{p}{/}\PY{n}{nrun}
\PYZbs{}\PY{n}{n}\PY{p}{'}\PY{p}{)}
            \PY{n}{ssf.write}\PY{p}{(}\PY{p}{'}\PYZbs{}\PY{n}{n}\PY{p}{'}\PY{p}{)}
            \PY{n}{ssf.write}\PY{p}{(}\PY{p}{'}\PY{n}{echo}\PY{p}{$}\PY{n}{pwd}\PYZbs{}\PY{n}{n}\PY{p}{'}\PY{p}{)}
            \PY{n}{ssf.write}\PY{p}{(}\PY{p}{'}\PYZbs{}\PY{n}{n}\PY{p}{'}\PY{p}{)}
            \PY{n}{ssf.write}\PY{p}{(}\PY{p}{'}\PY{n}{python3 generate_cases.py}
\PYZbs{}\PY{n}{n}\PY{p}{'}\PY{p}{)}
            \PY{n}{ssf.close}\PY{p}{(}\PY{p}{)}\PY{p}{;}
        \PY{n}{os.system}\PY{p}{(}\PY{n}{sbatch jobpyDAMPF}\PY{p}{)}\PY{p}{'}\PY{p}{+}\PY{n}{str}\PY{p}{(}\PY{n}{i}\PY{p}{)}\PY{p}{+}\PY{p}{'}
\PY{n}{.x}\PY{p}{;}\PY{p}{'}\PY{p}{)}
        \PY{n}{os.system}\PY{p}{(}\PY{n}{rm jobpyDAMPF}\PY{p}{)}\PY{p}{'}\PY{p}{+}\PY{n}{str}\PY{p}{(}\PY{n}{i}\PY{p}{)}\PY{p}{+}\PY{p}{'}\PY{n}{.x}\PY{p}{;}\PY{p}{'}\PY{p}{)}
\end{Verbatim}
\vspace{1mm}

The above script generates \textit{SLURM} jobs for a chosen set of threads; after launched, those jobs files are erased in order to improve bookkeeping

\item 
Parallel execution with \textit{UNIX} based Laptops or Desktops

Usually, microscopes (AFM) computers have no SLURM pre-installed; for such a configuration, we run the following script: 
\begin{Verbatim}[commandchars=\\\{\},fontsize=\footnotesize]

\PY{k}{def} \PY{n+nf}{compute}\PY{p}{(}\PY{n}{factor}\PY{p}{)}\PY{p}{:}
    \PY{n}{direc} \PY{o}{=} \PY{n}{os.getcwd}\PY{p}{(}\PY{p}{)}
    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in}\ \PY{n+nb}{range}\PY{p}{(}\PY{n}{1}\PY{p}{,}\PY{n}{factor+1}\PY{p}{)}\PY{p}{:} 
        \PY{n}{os.chdir}\PY{p}{(}\PY{n}{direc}\PY{p}{+}\PY{p}{'}\PY{p}{/}\PY{n}{PARALLELBASIC_0}\PY{p}{/}\PY{p}{'}\PY{p}{+}
                \PY{n}{str}\PY{p}{(}\PY{n}{i}\PY{p}{)}\PY{p}{+}\PY{p}{'}\PY{p}{/}\PY{n}{nrun}\PY{p}{'}\PY{p}{)}
        \PY{n}{os.system}\PY{p}{(}\PY{p}{'}\PY{n}{python3 generate_cases.py}
                \ \PY{p}{&}\PY{p}{'}\PY{p}{)}
        \PY{n}{os.chdir}\PY{p}{(}\PY{n}{direc}\PY{p}{)}
\end{Verbatim}
\vspace{1mm}
\end{itemize}

This function allows the proper execution of the parallel case without a queuing system and where a slight delay might appear from thread to thread execution.

\subsubsection{Analysis%
  \label{Analysis}%
}
\paragraph{Graphically}

\begin{itemize}
\item 
With static graphics, as shown in Figures \ref{fig2}, \ref{fig3}, \ref{fig4} and \ref{fig5}.

\begin{quote}
\begin{verbatim}
python3 Graphical_analysis.py
\end{verbatim}
\end{quote}

\end{itemize}


\begin{itemize}
\item 
With interactive graphics, as shown in \ref{fig6}.

\begin{quote}
\begin{verbatim}
pip install plotly
\end{verbatim}
\end{quote}

\begin{quote}                                                                                  
\begin{verbatim}
jupyter notebook Graphical_analysis.ipynb
\end{verbatim}
\end{quote}

\end{itemize}

\paragraph{Quantitatively}

\begin{itemize}
\item 
With static data table

\begin{quote}
\begin{verbatim}
python3 Quantitative_analysis.py
\end{verbatim}
\end{quote}
\end{itemize}


\begin{itemize}
\item 
With interactive tables

\textit{Quantitative\_analysis.ipynb} uses a minimalistic dashboard application for tabular data visualization
\href{https://github.com/bluenote10/tabloo}{tabloo} with easy installation.:
\begin{quote}
\begin{verbatim}
pip install tabloo
\end{verbatim}
\end{quote}

\begin{quote}
\begin{verbatim}
jupyter notebook Quantitative_analysis.ipynb
\end{verbatim}
\end{quote}
\end{itemize}


\subsection{Results and discussions%
  \label{Results and discussions}%
}

In Figure~\ref{fig1}, we show four scenarios to be tackled in this test-case for pyDAMPF. As described in the introduction, the first scenario (Figure~\ref{fig1}(a)), compares between air and moist environment, the second tackles soft and stiff cantilevers(see Figure~\ref{fig1}(b)), next is Figure  Figure~\ref{fig1}(c) with the cantilever volume comparison and the force the tip's radio (see Figure~\ref{fig1}(d)). Further details of the cantilevers depicted here are included in Table~\ref{tab:compare}.

\begin{figure}[H]

\centering
%\noindent\makebox[\columnwidth][c]
\subfigure(a){\includegraphics[width=40mm]{casoa.png}}
\subfigure(b){\includegraphics[width=40mm]{casob.png}}
\subfigure(c){\includegraphics[width=40mm]{casoc.png}}
\subfigure(d){\includegraphics[width=40mm]{casod.png}}
\caption{Schematic of the tip-sample interface comparing: (a) air at a given Relative Humidity with air; (b) a hard (stiff) cantilever with a soft cantilever; (c) a cantilever with a high volume compared with a cantilever with a small volume; (d) a cantilever with a wide tip with a cantilever with a sharp tip.} 

\label{fig1}
\end{figure}

The AFM is widely used for mechanical properties mapping of matter~\cite{GarciaRev2021}. Hence, the first comparison of the four scenarios points out to the force response versus time according to a Hertzian interaction~\cite{GuzmanScalingBJON2015}. In Figure~\ref{fig2}a, we see the humid air (RH = 60.1\%) changes the measurement conditions by almost 10\%. Using a stiffer cantilever ($k_c=2.7 [N/m]$) will also increase the force by almost 50\% from the softer one ($k_c=0.8 [N/m]$), see Figure~\ref{fig2}b. Interestingly, the cantilever's volume, a smaller cantilever, results in the highest force by almost doubling the force by almost five folds of the smallest volume (Figure~\ref{fig2}c). Finally, the Tip radius difference between 8 and 20 nm will impact the force in roughly 40 pN.

\begin{figure}[H]
\centering
%\noindent\makebox[\columnwidth][c]
\subfigure(a){\includegraphics[width=40mm]{fig2aHR3.png}}
\subfigure(b){\includegraphics[width=40mm]{fig2bHR3.png}}
\subfigure(c){\includegraphics[width=40mm]{fig2cHR3.png}}
\subfigure(d){\includegraphics[width=40mm]{fig2dHR3.png}}
\caption{Time-varying force for PVA at RH = 60.1\% for different cantilevers. The simulations show elastic (Hertz) responses. For each curve, the maximum force value is the peak force. Two complete oscillations are shown corresponding to the conditions in: (a)  Fig.~\ref{fig1}a, (b) Fig.~ \ref{fig1}b, (c) Fig.~ \ref{fig1}c, and (d) Fig.~\ref{fig1}d. The simulations were performed for $A_{sp}/A_{0}$ = 0.8 .} \label{fig2}
\end{figure}

Now, if we consider literature values for different RH~\cite{Modul1, Modul2}, we can evaluate the Peak or Maximum Forces. This force in all cases depicted in Figure~\ref{fig3} shows a monotonically increasing behaviour with the higher Young modulus. Remarkably, the force varies in a range of ~ 25\% from dried PVA to one at RH = 60.1\% (see Figure~\ref{fig3}a).
\begin{figure}[H]
\centering
%\noindent\makebox[\columnwidth][c]
\subfigure(a){\includegraphics[width=40mm]{fig3a.png}}
\subfigure(b){\includegraphics[width=40mm]{fig3b.png}}
\subfigure(c){\includegraphics[width=40mm]{fig3c.png}}
\subfigure(d){\includegraphics[width=40mm]{fig3d.png}}
\caption{Peak force reached for a PVA sample subjected to different relative humidities 0.0\%, 29.5\%, 39.9\% and 60.1\% corresponding to the conditions in (a) Fig.~\ref{fig1}a, (b) Fig.~\ref{fig1}b, (c) Fig.~\ref{fig1}c, and (d) Fig.~\ref{fig1}d. The simulations were performed for $A_{sp}/A_{0}$ = 0.8 .}\label{fig3}
\end{figure}

In order to properly describe operational parameters in dynamic AFM we analyze the peak force dependence with the set-point amplitude $A_{sp}$. In Figure~\ref{fig4}, we have the comparison of peak forces for the different cantilevers as a function of $A_{sp}$. The sensitivity of the peak force varies more with the type of cantilevers with contrary $k_c$ and $V_c$. Nonetheless, the peak force dependence given by the Hertzian mechanics has a dependence with the square root of the tip radius, and for those Radii on Table~\ref{tab:compare} are not influencing much the force. However, they could strongly influence resolution~\cite{GuzmanScalingBJON2013}.


\begin{figure}[H]
\centering
\subfigure(a){\includegraphics[width=40mm]{./fig4aHR3}}
\subfigure(b){\includegraphics[width=40mm]{./fig4bHR3}}
\subfigure(c){\includegraphics[width=40mm]{./fig4cHR3}}
\subfigure(d){\includegraphics[width=40mm]{./fig4dHR3}}
\caption{Dependence of the maximum force on the set-point amplitude corresponding to the conditions in: (a)  Fig.~\ref{fig1}a, (b) Fig.~\ref{fig1}b, (c) Fig.~\ref{fig1}c, and (d) Fig.~\ref{fig1}d.} \label{fig4}
\end{figure}

Figure~\ref{fig5} shows the dependence of the peak force as a function of $k_c$, $V_c$, and $R_T$, respectively, for all the cantilevers listed in Table~\ref{tab:compare}; constituting a graphical summary of the seven analyzed cantilevers for completeness of the analysis.

\begin{figure}[H]
\centering
%\subfigure(a){\includegraphics[width=70mm]{./fig5k2HR3}}
%\subfigure(b){\includegraphics[width=70mm]{./fig5r2HR3}}
%\subfigure(c){\includegraphics[width=70mm]{./fig5v2HR3}}
\subfigure{\includegraphics[width=\columnwidth]{./fig5cutCOMPLETEHR3}}
\caption{Dependence of the maximum force with the most important characteristics of each cantilever, filtering the cantilevers used for the scenarios , the figure shows maximum force dependent on the: (a)  force constant k, (b)  cantilever tip radius, and (c) cantilever volume, respectively. The simulations were performed for $A_{sp}/A_{0}$ = 0.8 .} \label{fig5}
\end{figure}

Another way to summarize the results in AFM simulations if to show the Force vs. Distance curves (see Fig.~\ref{fig7}), which in these case show exactly how for example a stiffer cantilever may penetrate more into the sample by simple checking the distance cantilever \textit{e} reaches. On the other hand, it also jumps into the eyes that a cantilever with small volume \textit{f} has less damping from the environment and thus it also indents more than the ones with higher volume. Although these type of plots are the easiest to make they carry lots of experimental information. In addition, pyDAMPF can plot such 3D figures interactively that enables a detailed comparison of those curves.

\begin{figure}[]
\centering
\subfigure(a){\includegraphics[width=55mm]{./fig6HR0}}
%\subfigure[]{\includegraphics[width=50mm]{./fig6HR1}}
%\subfigure[]{\includegraphics[width=50mm]{./fig6HR2}}
\subfigure(b){\includegraphics[width=55mm]{./fig6HR3}}
\caption{Three-dimensional plots of the various cantilevers provided by the manufacturer and those in the pyDAMPF database that establish a given maximum force at a given distance between the tip and the sample for a PVA polymer subjected to : (a) RH= 0\% with E = 930 [MPa]. and (b) RH = 60.1\% with E = 248.8 [MPa].} \label{fig6}
\end{figure}

As we aim a massive use of pyDAMPF, we also perform the corresponding benchmarks on four different computing platforms, where two of them resembles the standard PC or Laptop found at the labs, and the other two aim to cloud and HPC facilities, respectively (see Table~\ref{tab:computador} for details).

Figure~\ref{fig7}a shows the average run time for the serial and parallel implementation. Despite a slightly higher performance for the case of the HPC cluster nodes, a high-end computer (PC 2) may also reach similar values, which is our current goal. Another striking aspect observed by looking at the speed-up, is the maximum and minimum run times, which notoriously show the on-demand character of cloud services. As their maxima and minima show the highest variations.


\renewcommand{\tablename}{Tabla}
\begin{table*}[ht]
\caption{Data used for Figs.~\ref{fig2}, \ref{fig3} and \ref{fig4} with an $A_0 = 10 [nm]$. Observe that the quality factor and Young's modulus have three different values respectively for RH1 = 29.5\%, RH2 = 39.9\% y RH3 = 60.1\%. $^{**}$ The values presented for Quality Factor ($Q$) were calculated at  \href{https://colab.research.google.com/drive/1O1xjLfmMoL6J4EwVods95zfelzr8GDUQ?usp=sharing}{Google Colaboratory notebook Q\_calculation},using the method proposed by \cite{Sader, Sader2}}
\centering
%\begin{tabular}{p{0.10\linewidth}p{0.15\linewidth}p{0.08\linewidth}p{0.18\linewidth}p{0.15\linewidth}p{0.08\linewidth}p{0.08\linewidth}}
\begin{tabular}{ c  c  c  c  c  c  c  c  c }
\hline
Scenario  & Model & $R$[nm] & $Q^{**}$ & $E_s$[MPa] & $k$[N/m] & $f$[kHz] & Volume [$\mu m^3$] & Cantilever\\ \hline
\textcolor{blue}{Air} & PPP-CONTSCR & 7 & 28.65 & 930 & 0.2 & 25 & 10800 & a\\
\textcolor{orange}{Humid air}& PPP-CONTSCR & 7 & 28.74 - 28.77 - 28.83 & 595.6 - 477.8 - 247.8 & 0.2 & 25 & 10800 &a \\
\textcolor{cyan}{Hard} & XCS11-B & 10 & 167.73 - 167.89 - 168.28 & 595.6 - 477.8 - 247.8 & 2.7 & 80 & 17010 & e \\
\textcolor{magenta}{Soft} & HQ:CSC37-A & 10 & 95.15 - 95.24 - 94.45 & 595.6 - 477.8 - 247.8 & 0.8 & 40 & 17500 & d \\
\textcolor{rebeccapurple}{High vol.} & PPP-XY-CONTR & 10 & 48.37 - 48.41 - 48.51 & 595.6 - 477.8 - 247.8 & 0.2 & 13 & 45000 & g \\
\textcolor{yellowgreen}{Small vol.} & SD-PXL-CONT-SC & 10 & 23.61 - 23.64 - 23.68 & 595.6 - 477.8 - 247.8 & 0.2 & 8 & 10125 & f \\
\textcolor{darkviolet}{Wide $R_T$} & SD-CONT-SiN* & 20 & 48.37 - 48.41 - 48.51 & 595.6 - 477.8 - 247.8 & 0.2 & 13 & 45000 & b \\
\textcolor{gold}{Sharp $R_T$} & CONTR & 8 & 48.37 - 48.41 - 48.51 & 595.6 - 477.8 - 247.8 & 0.2 & 13 & 45000 & c \\ \hline
\end{tabular}
\label{tab:compare}
\end{table*}


\renewcommand{\tablename}{Tabla}
\begin{table*}[ht]
\caption{Computers used to run pyDAMPF and Former work \cite{dForce}, $^*$ the free version of Colab provides this capability, there are two paid versions which provide much greater capacity, these versions known as Colab Pro and Colab Pro+ are only available in some countries.}
\centering
\begin{tabular}{c c c c c}
\hline
Computer & CPU & RAM & pyDAMPF & Forme Work\\ \hline
PC 1 & Core i5-5200U @ 2.2 GHz & 8 GB & \Checkmark & \Checkmark \\
PC 2 & Ryzen 7 4800H @ 2.9 GHz & 16GB & \Checkmark & \Checkmark \\
Colab & Intel(R) Xeon(R) CPU @ 2.2GHz & 6.4GB$^*$ & \Checkmark & - \\
Cluster & Intel(R) Xeon(R) E5-2620 v4 @ 2.1GHz & 32 GB & \Checkmark & -  \\ \hline
\end{tabular}
\label{tab:computador}
\end{table*}



\begin{figure}[]
\centering
%\subfigure[]{\includegraphics[width=60mm]{./fig7promhilos}}
%\subfigure[]{\includegraphics[width=60mm]{./fig7serial}}
\subfigure[]{\includegraphics[width=80mm]{./fig7serialvsparalelo1}}
\subfigure[]{\includegraphics[width=80mm]{./fig7speedblox}}
%\subfigure[]{\includegraphics[width=80mm]{./fig7speed2}}
%\subfigure[]{\includegraphics[width=50mm]{./fig7max}}
%\subfigure[]{\includegraphics[width=50mm]{./fig7min}}
%\subfigure[]{\includegraphics[width=60mm]{./fig7hilos1}}
\caption{Comparison of execution times: (a) Comparison of times taken by both the parallel method and the serial method. (b) Speed up parallel method.
} \label{fig7}
\end{figure}

\renewcommand{\tablename}{Tabla}
\begin{table}[h]
\caption{Execution times per computational thread, for each computer. Note that each Thread consist of 9 simulation cases, with a sum time showing the total of 90 cases for evaluating 3 different Young moduli and 30 cantilevers at the same time.}
\centering
\begin{tabular}{c c c c c}
\hline
\multicolumn{5}{ c }{Time of execution for thread [min]} \\ \hline
Thread & PC 1 & PC 2 & Colab & Cluster\\ \hline
1 & 123.81 & 60.19 & 151.10 & 55.19 \\
2 & 116.12 & 61.23 & 151.94 & 54.96 \\
3 & 123.73 & 60.09 & 148.94 & 52.87 \\
4 & 120.41 & 60.26 & 62.01 & 54.24 \\
5 & 122.27 & 60.35 & 61.39 & 55.48 \\
6 & 119.93 & 59.97 & 59.91 & 52.96 \\
7 & 122.70 & 60.68 & 149.89 & 54.72 \\
8 & 124.19 & 60.55 & 166.58 & 54.54 \\
9 & 121.34 & 60.99 & 136.69 & 54.36 \\
10 & 123.36 & 60.57 & 152.88 & 57.75 \\ \hline
Average & 121.78 & 60.49 & 124.13 & 54.71  \\
Sum & 1217.85 & 604.89 & 1241.33 & 547.07   \\ \hline
\end{tabular}
\label{tab:time}
\end{table}

To calculate the speed up we use the following equation:

\begin{equation}
S = \frac{t_{total}}{t_{thread}} %= \frac{Case_{time}}{Thread_{average}}
\end{equation} 

Where $S$ is the speed up , $t_{Thread}$ is the execution time of a computational thread, and $t_{Total}$ is the sum of times, shown in the table \ref{tab:time}. For our calculations we used the highest, the average and the lowest execution time per thread.%, the data is shown in (\ref{fig7} and in the table \ref{tab:speedup}.

\renewcommand{\tablename}{Tabla}
%\begin{table}[h]

%\caption{\textcolor{red}{Execution times per computational thread, for each computer. Note that each Thread consist of 9 simulation cases, with a sum time showing the total of 90 cases for evaluating 3 different Young module and 30 cantilevers at the same time} using equation (1) .}
%\centering
%\begin{tabular}{c c c c c}
%\hline

%Time & PC 1 & PC 2 & Colab & Cluster\\ \hline
%$Thread_{min}$ & 116.12 & 59.97 & 59.91 & 52.87 \\
%$Thread_{max}$  & 124.19 & 61.23 & 166.58 & 57.75 \\
%$Thread_{average}$  & 121.78 & 60.49 & 124.13 & 54.71 \\ 
%$Total_{time}$ & 1,217.85 & 604.89 & 1,241.33 & 547.07 \\ \hline
%\multicolumn{5}{ c }{Speep up} \\ \hline
%$Speed$ $up_{min}$ & 10.49 & 10.09 & 20.72 & 10.35 \\
%$Speed$ $up_{max}$  & 9.81 & 9.88 & 7.45 & 9.47 \\ 
%$Speed$ $up_{average}$  & 10.00 & 9.99 & 10.00 & 9.99 \\ \hline

%\end{tabular}
%\label{tab:speedup}
%\end{table}


\subsection{Limitations%
  \label{limitations}%
}

The main limitation of dynamic AFM simulators based in continuum modeling is that some times a molecular behaviour is overlooked. Such a limitation comes from the multiple time and length scales behind the physics of complex systems, as it is the case of polymers and biopolymers. In this regard, several efforts on the multiscale modeling of materials have been proposed, joining mainly efforts to stretch the multiscale gap~\cite{GuzmanCPC2019}. We also plan to do so, within a current project, for modeling the polymeric fibers as molecular chains and providing "feedback" between models from a top-down strategy.
Code-wise, the implementation will be also gradually improved. Nonetheless, to maintain scientific code is a challenging tasks. In particular without the support for our students once they finish their thesis. In this respect, we will seek for software funding and more community contributions.

\subsection{Future work%
  \label{future-work}%
}


There are several improvements that are planned for pyDAMPF.
\begin{itemize}
\item 

We plan to include a link to molecular dynamics simulations of polymer chains in a multiscale like approach.

\item

We plan to use experimental values with less uncertainty to boost semi-empirical models based on pyDAMPF.


\item 

The code is still not very clean and some internal cleanup is necessary.
This is especially true for the Python backend which may require a refactoring.

\item
Some AI optimization was also envisioned, particularly for optimizing criteria and comparing operational parameters.

\end{itemize}



\subsection{Conclusions%
  \label{Conclusions}%
}

%\subsection{High-level overview%
  %\label{high-level-overview}%
%}


In summary, pyDAMPF is a highly efficient and adaptable simulation tool aimed at analyzing, planning and interpreting dynamic AFM experiments. 

It is important to keep in mind that pyDAMPF uses cantilever manufacturers information to analyze, evaluate and choose a certain nanoprobe that fulfills experimental criteria. If this will not be the case, it will advise the experimentalists on what to expect from their measurements and the response a material may have. We currently support multi-thread execution using in-house development. However, in our outlook, we plan to extend the code to GPU by using transpiling tools, like compyle~\cite{compyleScipy2019}, as the availability of GPUs also increases in standard workstations.
In addition, we have shown how to reuse a widely tested Fortran code~\cite{GuzmanACSnano2013} and wrap it as a python module to profit from pythonic libraries and interactivity via Jupyter notebooks. Implementing new interaction forces for the simulator is straightforward. However, this code includes the state-of-the-art contact, viscous, van der Waals, capillarity and electrostatic forces used for physics at the interfaces.
Moreover, we plan to implement soon semi-empirical analysis and multiscale modeling with molecular dynamics simulations.


\subsection{Acknowledgments%
  \label{acknowledgments}%
}

H.V.G thanks the financial support by the Slovenian Research Agency (Funding No. P1-0055).
We gratefully acknowledge the fruitful discussions with Tomas Corrales. 
%Our thanks to the reviewers for their feedback that has significantly improved the manuscript.
\bibliographystyle{alphaurl}
\bibliography{references}

\end{document}
